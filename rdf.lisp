(in-package :cl-conllu)

;; (wilbur:add-namespace "conll" "http://br.ibm.com/conll/")

;; @prefix conll: <http://example.com/> .
;; @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
;; @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
;; @prefix dc: <http://purl.org/dc/elements/1.1/> .
;; @prefix dcterms: <http://purl.org/dc/terms/> .
;; @prefix skos: <http://www.w3.org/2004/02/skos/core#> .
;; @prefix owl: <http://www.w3.org/2002/07/owl#> .

;; from Wilbur2
(defun components->string (components)
  (with-output-to-string (stream)
    (dolist (component components)
      (princ component stream))))

;; from Wilbur2
(defun escape-string (string char-escape-function)
  ;; This tries to be clever about stuff that does not need to be escaped
  (labels ((escape (s n i parts)
             (let ((j (position-if char-escape-function s :start i)))
               (cond (j (escape s n (1+ j)
                                (list* (funcall char-escape-function (char s j))
                                       (subseq s i j)
                                       parts)))
                     (parts (components->string (nreverse (cons (subseq s i) parts))))
                     (t s)))))
    (escape string (length string) 0 nil)))

;; from Wilbur2
(defun escape-turtle-char (char)
  (cdr (assoc char '((#\\ . "\\\\")
                     (#\" . "\\\"")
                     (#\Linefeed . "\\n")
                     (#\Return . "\\r")
                     (#\Tab . "\\t"))
              :test #'char=)))

(defun make-literal (string)
  (format nil "\"~a\"" (escape-string string #'escape-turtle-char)))

(defun make-token-id (sentence-id token-id)
  (format nil "~at~a" sentence-id token-id))

(defun make-upos (upos)
  (format nil "conll:~a"
          (cdr (assoc upos
                      (pairlis
                       '("ADJ" "ADP" "ADV" "AUX" "CONJ" "DET" "INTJ" "NOUN" "NUM" "PART" "PRON" "PROPN" "PUNCT" "SCONJ" "SYM" "VERB" "X")
                       '("Adj" "Adp" "Adv" "Aux" "Conj" "Det" "Intj" "Noun" "Num" "Part" "Pron" "PropN" "Punct" "SConj" "Sym" "Verb" "X"))
                      :test #'string-equal))))

(defun make-dep (dep)
  (format nil "conll:~a" dep))

(defun make-features (features)
  (unless (string-equal features "_")
    (format nil "~{ ~a~^;~}" 
            (mapcar (lambda (f) (destructuring-bind (name value) (split-sequence #\= f)
                                  (format nil "conll:~a conll:~a" (string-downcase name) value))) 
                    (split-sequence #\| features :remove-empty-subseqs t)))))

(defun convert-sentence-to-turtle (stream conll text id)
  (format stream "conll:~a a conll:Sentence .~%" id)
  (format stream "conll:~a rdfs:label ~a .~%" id (make-literal text))
  (format stream "conll:~a conll:tokens (~{~a~^ ~}) .~%" id 
   (mapcar (lambda (tk) (format nil "conll:~a" (make-token-id id (slot-value tk 'id)))) (sentence-tokens conll)))

  (dolist (tk (sentence-tokens conll))
    (let ((tid (make-token-id id (slot-value tk 'id)))
          (form (slot-value tk 'form))
          (lemma (slot-value tk 'lemma))
          (upostag (slot-value tk 'upostag))
          (xpostag (slot-value tk 'xpostag))
          (feats (make-features (slot-value tk 'feats)))
          (head (make-token-id id (slot-value tk 'head)))
          (deprel (slot-value tk 'deprel))
          (deps (slot-value tk 'deps))
          (misc (slot-value tk 'misc)))
      (format stream "conll:~a conll:form ~a .~%" tid (make-literal form))
      (format stream "conll:~a conll:lemma ~a .~%" tid (make-literal lemma))
      (format stream "conll:~a conll:upos ~a .~%" tid (make-upos upostag))
      (format stream "conll:~a conll:xpos ~a .~%" tid (make-literal xpostag))
      (when feats
       (format stream "conll:~a conll:features [ ~a ] .~%" tid feats))
      (if (string-equal "root" deprel)
          (format stream "conll:~a conll:root conll:~a .~%" id tid)
          (format stream "conll:~a ~a conll:~a .~%" tid (make-dep deprel) head)))))

(defun convert-conll (stream conlls text-fn id-fn)
  "Converts the collection of sentences (as generated by READ-CONLLU)
in CONLL, using the function TEXT-FN to extract the text of each
sentence and ID-FN to extract the id of each sentence (we need this as
there is no standardized way of knowing this.)"
  (format stream "@prefix conll: <http://br.ibm.com/conll/> . @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . @prefix dc: <http://purl.org/dc/elements/1.1/> . @prefix dcterms: <http://purl.org/dc/terms/> . @prefix skos: <http://www.w3.org/2004/02/skos/core#> . @prefix owl: <http://www.w3.org/2002/07/owl#> .")

  (dolist (c conlls)
    (convert-sentence-to-turtle stream c (funcall text-fn c) (funcall id-fn c))))


(defun convert-bosque ()
  (with-open-file (out "bosque.ttl" :direction :output :if-exists :supersede)
    (convert-conll out (read-conllu "bosque.udep.conll")
                   (lambda (s) (cdr (assoc "text" (sentence-meta s) :test #'equal)))
                   (lambda (s) (cdr (assoc "ref" (sentence-meta s) :test #'equal))))))
